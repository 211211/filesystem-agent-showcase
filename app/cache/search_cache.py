"""
Search results cache with scope-aware invalidation.

This module provides a specialized cache for search operation results (grep, find, etc.)
with intelligent invalidation based on file system changes. The cache uses deterministic
key generation and tracks file state to automatically invalidate stale results.
"""

import hashlib
import json
import logging
from pathlib import Path
from typing import Optional

from app.cache.disk_cache import PersistentCache
from app.cache.file_state import FileStateTracker

logger = logging.getLogger(__name__)


class SearchCache:
    """
    Cache search results with scope-aware invalidation.

    This class provides caching for search operations (grep, find, etc.) with automatic
    invalidation when files in the search scope change. Cache keys are deterministically
    generated from the operation parameters, ensuring consistent lookups.

    Attributes:
        _cache: Underlying PersistentCache for storage
        _tracker: FileStateTracker for detecting file changes
        _search_prefix: Prefix for all search cache keys

    Example:
        >>> cache = PersistentCache()
        >>> tracker = FileStateTracker(cache)
        >>> search_cache = SearchCache(cache, tracker)
        >>>
        >>> # Cache a grep result
        >>> scope = Path("/path/to/search")
        >>> options = {"case_sensitive": True, "max_results": 100}
        >>> await search_cache.set_search_result(
        ...     operation="grep",
        ...     pattern="TODO",
        ...     scope=scope,
        ...     options=options,
        ...     result="file1.py:10:# TODO: fix this",
        ...     ttl=300
        ... )
        >>>
        >>> # Retrieve cached result (returns None if files changed)
        >>> result = await search_cache.get_search_result(
        ...     operation="grep",
        ...     pattern="TODO",
        ...     scope=scope,
        ...     options=options
        ... )
    """

    def __init__(self, disk_cache: PersistentCache, state_tracker: FileStateTracker):
        """
        Initialize the search cache.

        Args:
            disk_cache: PersistentCache instance for storing search results
            state_tracker: FileStateTracker for detecting file changes
        """
        self._cache = disk_cache
        self._tracker = state_tracker
        self._search_prefix = "_search:"

    def _make_key(
        self,
        operation: str,
        pattern: str,
        scope: Path,
        options: dict,
    ) -> str:
        """
        Create deterministic cache key for a search operation.

        The key is generated by hashing a JSON representation of the operation
        parameters, ensuring that identical searches produce identical keys.

        Args:
            operation: Type of search operation (e.g., "grep", "find")
            pattern: Search pattern or query
            scope: Directory or file path being searched
            options: Additional search options (e.g., case_sensitive, max_results)

        Returns:
            A deterministic cache key string prefixed with "_search:"

        Note:
            The key uses SHA256 hash (first 16 characters) of the sorted
            JSON representation, ensuring determinism across runs.

        Example:
            >>> key = cache._make_key(
            ...     operation="grep",
            ...     pattern="TODO",
            ...     scope=Path("/home/user/project"),
            ...     options={"case_sensitive": True}
            ... )
            >>> print(key)
            '_search:a1b2c3d4e5f6g7h8'
        """
        key_data = {
            "op": operation,
            "pattern": pattern,
            "scope": str(scope.resolve()),
            "options": sorted(options.items()),
        }
        key_str = json.dumps(key_data, sort_keys=True)
        key_hash = hashlib.sha256(key_str.encode()).hexdigest()[:16]
        return f"{self._search_prefix}{key_hash}"

    async def get_search_result(
        self,
        operation: str,
        pattern: str,
        scope: Path,
        options: dict,
    ) -> Optional[str]:
        """
        Get cached search result if scope hasn't changed.

        This method retrieves a cached search result and validates that the
        search scope (file or directory) hasn't been modified since the result
        was cached. If the scope is stale, the cache entry is deleted and None
        is returned.

        Args:
            operation: Type of search operation (e.g., "grep", "find")
            pattern: Search pattern or query
            scope: Directory or file path that was searched
            options: Search options used in the original search

        Returns:
            Cached search result string if valid, None if cache miss or scope is stale

        Example:
            >>> result = await search_cache.get_search_result(
            ...     operation="grep",
            ...     pattern="ERROR",
            ...     scope=Path("/var/log"),
            ...     options={"case_sensitive": False}
            ... )
            >>> if result:
            ...     print("Cache hit:", result)
            ... else:
            ...     print("Cache miss or stale")
        """
        key = self._make_key(operation, pattern, scope, options)

        # Check if any file in scope has changed
        if await self._is_scope_stale(scope):
            await self._cache.delete(key)
            logger.debug(
                f"Cache MISS (stale): {operation} pattern={pattern} scope={scope}"
            )
            return None

        result = await self._cache.get(key)
        if result is not None:
            logger.debug(
                f"Cache HIT: {operation} pattern={pattern} scope={scope}"
            )
        else:
            logger.debug(
                f"Cache MISS: {operation} pattern={pattern} scope={scope}"
            )

        return result

    async def set_search_result(
        self,
        operation: str,
        pattern: str,
        scope: Path,
        options: dict,
        result: str,
        ttl: float = 300,  # 5 minutes default
    ) -> None:
        """
        Cache search result with TTL and scope state tracking.

        Stores the search result in the cache with an expiration time and records
        the current state of the search scope for future staleness detection.

        Args:
            operation: Type of search operation (e.g., "grep", "find")
            pattern: Search pattern or query
            scope: Directory or file path that was searched
            options: Search options used in the search
            result: Search result string to cache
            ttl: Time-to-live in seconds (default: 300 seconds / 5 minutes)

        Example:
            >>> await search_cache.set_search_result(
            ...     operation="find",
            ...     pattern="*.py",
            ...     scope=Path("/home/user/project"),
            ...     options={"recursive": True},
            ...     result="file1.py\\nfile2.py\\nfile3.py",
            ...     ttl=600  # 10 minutes
            ... )

        Note:
            The TTL ensures that even if files don't change, the cache entry
            will be refreshed periodically to account for potential missed changes.
        """
        key = self._make_key(operation, pattern, scope, options)
        await self._cache.set(key, result, expire=ttl)
        await self._update_scope_state(scope)

        logger.debug(
            f"Cache SET: {operation} pattern={pattern} scope={scope} ttl={ttl}s"
        )

    async def _is_scope_stale(self, scope: Path) -> bool:
        """
        Check if the search scope has changed since caching.

        Determines whether files in the search scope have been modified,
        added, or deleted since the search result was cached.

        Args:
            scope: Directory or file path to check

        Returns:
            True if the scope is stale (has changed), False otherwise

        Note:
            For files, checks the file's modification time, size, and content hash.
            For directories, checks the directory's modification time as a proxy
            for changes (faster than checking all files recursively).
        """
        if scope.is_file():
            return await self._tracker.is_stale(scope)

        # For directories, check directory mtime
        # (faster than checking all files)
        return await self._tracker.is_stale(scope)

    async def _update_scope_state(self, scope: Path) -> None:
        """
        Update the tracked state for the search scope.

        Records the current state (mtime, size, hash) of the scope for
        future staleness detection.

        Args:
            scope: Directory or file path to track
        """
        await self._tracker.update_state(scope)

    async def invalidate_pattern(
        self,
        operation: str,
        pattern: str,
        scope: Path,
        options: dict,
    ) -> bool:
        """
        Manually invalidate a specific search cache entry.

        Useful for forcing cache refresh for a specific search operation
        without waiting for automatic staleness detection.

        Args:
            operation: Type of search operation
            pattern: Search pattern
            scope: Directory or file path
            options: Search options

        Returns:
            True if the entry was found and deleted, False otherwise

        Example:
            >>> deleted = await search_cache.invalidate_pattern(
            ...     operation="grep",
            ...     pattern="TODO",
            ...     scope=Path("/home/user/project"),
            ...     options={"case_sensitive": True}
            ... )
            >>> if deleted:
            ...     print("Cache entry invalidated")
        """
        key = self._make_key(operation, pattern, scope, options)
        deleted = await self._cache.delete(key)

        if deleted:
            logger.info(
                f"Cache INVALIDATED: {operation} pattern={pattern} scope={scope}"
            )
        else:
            logger.debug(
                f"Cache INVALIDATE (not found): {operation} pattern={pattern} scope={scope}"
            )

        return deleted
